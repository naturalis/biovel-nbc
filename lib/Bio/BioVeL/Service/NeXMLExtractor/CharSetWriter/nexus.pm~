package Bio::BioVeL::Service::NeXMLExtractor::CharSetWriter::nexus;
use strict;
use warnings;
use Bio::BioVeL::Service::NeXMLExtractor::CharSetWriter;
use base 'Bio::BioVeL::Service::NeXMLExtractor::CharSetWriter';

=over

=item read_charsets

Reads character set definitions from a NEXUS file. The syntax is expected to be like what
is used inside C<mrbayes> blocks and inside C<sets> blocks, i.e.:

	charset <name> = <start coordinate>(-<end coordinate>)?(\<phase>)? ...;

That is, the definition starts with the C<charset> token, a name and an equals sign. Then,
one or more coordinate sets. Each coordinate set has a start coordinate, an optional end
coordinate (otherwise it's interpreted as a single site), and an optional phase statement,
e.g. for codon positions. Alternatively, instead of coordinates, names of other character 
sets may be used. The statement ends with a semicolon. 

Internally, everything after the C<charset> token is dispatched to 
L<Bio::BioVeL::Service::NeXMLMerger::CharSetReader::text::read_charset> which implements
the actual parsing. Subsequently, the collection of character sets is then dispatched to
L<Bio::BioVeL::Service::NeXMLMerger::CharSetReader::text::resolve_references> to 
resolve any named character sets that were referenced in lieu of coordinate sets. The
coordinate sets of the referenced character sets are deepcloned to replace the reference. 

=back

=cut

sub write_charsets {
        my ( $self, @charsets ) = @_;
        print "HIER!!!!\n";
#my @setnames = uniq map {${$_}{"ref"}} @charsets;
        #
        #my $str = "#nexus\n";
        #$str .= "begin sets;\n";
        
        #foreach my $name (@setnames) {
        #        $str .= "charset $name = ";
        #        my @sets = grep {${$_}{"ref"} eq $name} @charsets;
        #        foreach my $set (@sets) {
        #                $str .= $set->{"start"} == $set->{"end"} ? $set->{"start"} : $set->{"start"} . "-" . $set->{"end"};
        #                my $phase = $set->{"phase"};
        #                if ($phase > 1){
        #                        $str .= "\\" . $phase;
        #                }
        #                $str .= " ";
        #        }
        #        $str .= ";\n";       
        #}
       
        #$str .= "end;\n";
        
        return 1;#$str;


}

1;

